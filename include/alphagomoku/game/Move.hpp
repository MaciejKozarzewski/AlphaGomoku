/*
 * Move.hpp
 *
 *  Created on: Feb 20, 2021
 *      Author: Maciej Kozarzewski
 */

#ifndef ALPHAGOMOKU_MCTS_MOVE_HPP_
#define ALPHAGOMOKU_MCTS_MOVE_HPP_

#include <string>
#include <cassert>

namespace ag
{
	enum class Sign : int16_t
	{
		NONE, // empty spot on board
		CROSS, // or black
		CIRCLE, // or white
		ILLEGAL // typically outside of board
	};
	inline constexpr Sign invertSign(Sign sign) noexcept
	{
		switch (sign)
		{
			default:
				return sign;
			case Sign::CROSS:
				return Sign::CIRCLE;
			case Sign::CIRCLE:
				return Sign::CROSS;
		}
	}
	std::string toString(Sign sign);
	Sign signFromString(const std::string &str);
	Sign signFromText(char c) noexcept;
	std::string text(Sign sign);
	std::ostream& operator<<(std::ostream &stream, Sign sign);
	std::string operator+(const std::string &lhs, Sign rhs);
	std::string operator+(Sign lhs, const std::string &rhs);

	struct Location
	{
			int8_t row = 0;
			int8_t col = 0;
			Location() noexcept = default;
			Location(int r, int c) noexcept :
					row(r),
					col(c)
			{
				assert(-128 <= row && row < 128);
				assert(-128 <= col && col < 128);
			}
			/**
			 * @brief Creates location from text representation, as generated by method. text().
			 */
			Location(const std::string &str);
			std::string toString() const;
			/**
			 * @brief Converts the location to text representation with format:
			 * 1 character for column - starting from 'a', lowercase, from left to right
			 * 1 or 2 digits for row - starting from 0, from top to bottom
			 *
			 * For example:
			 * a0 - in the upper left corner.
			 * c2 - in the second row and third column.
			 */
			std::string text() const;
			uint16_t toShort() const noexcept
			{
				return Location::to_short(row, col);
			}

			static uint16_t to_short(int r, int c) noexcept
			{
				return (c << 8) | r;
			}
			static Location from_short(uint16_t loc) noexcept
			{
				return Location(get_row(loc), get_col(loc));
			}
			static int get_row(uint16_t loc) noexcept
			{
				return loc & 255;
			}
			static int get_col(uint16_t loc) noexcept
			{
				return loc >> 8;
			}

			friend bool operator==(const Location &lhs, const Location &rhs) noexcept
			{
				return lhs.row == rhs.row and lhs.col == rhs.col;
			}
			friend bool operator!=(const Location &lhs, const Location &rhs) noexcept
			{
				return not (lhs == rhs);
			}
	};

	struct Move
	{
			Sign sign = Sign::NONE;
			int8_t row = 0;
			int8_t col = 0;

			Move() = default;
			Move(Sign s, Move m) noexcept :
					sign(s),
					row(m.row),
					col(m.col)
			{
			}
			/**
			 * @brief Creates move from text representation, as generated by method. text().
			 */
			Move(const std::string &str);
			Move(int r, int c, Sign s) noexcept :
					sign(s),
					row(r),
					col(c)
			{
				assert(-128 <= row && row < 128);
				assert(-128 <= col && col < 128);
			}
			Move(Sign s, int r, int c) noexcept :
					sign(s),
					row(r),
					col(c)
			{
				assert(-128 <= row && row < 128);
				assert(-128 <= col && col < 128);
			}
			Move(int r, int c) noexcept :
					Move(Sign::NONE, r, c)
			{
			}
			Move(Location location, Sign s) noexcept :
					Move(location.row, location.col, s)
			{
			}
			Move(Sign s, Location location) noexcept :
					Move(location.row, location.col, s)
			{
			}
			Move(Location location) noexcept :
					Move(Sign::NONE, location)
			{
			}

			uint16_t toShort() const noexcept
			{
				return Move::move_to_short(row, col, sign);
			}
			Location location() const noexcept
			{
				return Location(row, col);
			}

			std::string toString() const;
			/**
			 * @brief Converts the move to text representation with format:
			 * 1 character for sign - '_', 'X', 'O' or '|'
			 * 1 character for column - starting from 'a', lowercase, from left to right
			 * 1 or 2 digits for row - starting from 0, from top to bottom
			 *
			 * For example:
			 * Xa0 - cross (or black) in the upper left corner.
			 * Oc2 - circle (or white) in the second row and third column.
			 */
			std::string text() const;

			static uint16_t move_to_short(int r, int c, Sign s) noexcept
			{
				return static_cast<uint16_t>(s) + (r << 2) + (c << 9);
			}
			static Move move_from_short(uint16_t m) noexcept
			{
				return Move(static_cast<Sign>(m & 3), (m >> 2) & 127, (m >> 9) & 127);
			}
			static int getRow(uint16_t move) noexcept
			{
				return (move >> 2) & 127;
			}
			static int getCol(uint16_t move) noexcept
			{
				return (move >> 9) & 127;
			}
			static Sign getSign(uint16_t move) noexcept
			{
				return static_cast<Sign>(move & 3);
			}
			/**
			 * @brief Creates a move from text representation that does not contain sign information.
			 */
			static Move fromText(const std::string &txt, Sign sign);

			friend bool operator==(const Move &lhs, const Move &rhs) noexcept
			{
				return (lhs.row == rhs.row) && (lhs.col == rhs.col) && (lhs.sign == rhs.sign);
			}
			friend bool operator!=(const Move &lhs, const Move &rhs) noexcept
			{
				return not (lhs == rhs);
			}
	};

} /* namespace ag */

#endif /* ALPHAGOMOKU_MCTS_MOVE_HPP_ */
