/*
 * Move.hpp
 *
 *  Created on: Feb 20, 2021
 *      Author: Maciej Kozarzewski
 */

#ifndef ALPHAGOMOKU_GAME_MOVE_HPP_
#define ALPHAGOMOKU_GAME_MOVE_HPP_

#include <cstdint>
#include <string>
#include <cassert>

namespace ag
{
	enum class Sign : int16_t
	{
		NONE, // empty spot on board
		CROSS, // or black
		CIRCLE, // or white
		ILLEGAL // typically outside of board
	};
	inline constexpr Sign invertSign(Sign sign) noexcept
	{
		switch (sign)
		{
			default:
				return sign;
			case Sign::CROSS:
				return Sign::CIRCLE;
			case Sign::CIRCLE:
				return Sign::CROSS;
		}
	}
	std::string toString(Sign sign);
	Sign signFromString(const std::string &str);
	Sign signFromText(char c) noexcept;
	std::string text(Sign sign);
	std::ostream& operator<<(std::ostream &stream, Sign sign);
	std::string operator+(const std::string &lhs, Sign rhs);
	std::string operator+(Sign lhs, const std::string &rhs);

	struct alignas(2) Location
	{
			int8_t row = 0;
			int8_t col = 0;
			constexpr Location() noexcept = default;
			/**
			 * @brief Creates location from text representation, as generated by method. text().
			 */
			Location(const std::string &str);
			constexpr Location(int r, int c) noexcept :
					row(r),
					col(c)
			{
				assert(0 <= row && row < 32);
				assert(0 <= col && col < 32);
			}
			constexpr explicit Location(uint16_t loc) noexcept :
					Location(loc & 255, loc >> 8)
			{
			}

			constexpr uint16_t toShort() const noexcept
			{
				return (col << 8) | row;
			}

			std::string toString() const;
			/**
			 * @brief Converts the location to text representation with format:
			 * 1 character for column - starting from 'a', lowercase, from left to right
			 * 1 or 2 digits for row - starting from 0, from top to bottom
			 *
			 * For example:
			 * a0 - in the upper left corner.
			 * c2 - in the second row and third column.
			 */
			std::string text() const;

			friend bool operator==(const Location &lhs, const Location &rhs) noexcept
			{
				return lhs.row == rhs.row and lhs.col == rhs.col;
			}
			friend bool operator!=(const Location &lhs, const Location &rhs) noexcept
			{
				return not (lhs == rhs);
			}
	};

	struct alignas(4) Move
	{
			Sign sign = Sign::NONE;
			int8_t row = 0;
			int8_t col = 0;

			Move() = default;
			Move(Sign s, Move m) noexcept :
					sign(s),
					row(m.row),
					col(m.col)
			{
			}
			/**
			 * @brief Creates move from text representation, as generated by method. text().
			 */
			Move(const std::string &str);
			constexpr Move(int r, int c, Sign s) noexcept :
					sign(s),
					row(r),
					col(c)
			{
				assert(0 <= row && row < 32);
				assert(0 <= col && col < 32);
			}
			constexpr Move(Sign s, int r, int c) noexcept :
					Move(r, c, s)
			{
			}
			constexpr Move(int r, int c) noexcept :
					Move(Sign::NONE, r, c)
			{
			}
			constexpr Move(Location location, Sign s) noexcept :
					Move(location.row, location.col, s)
			{
			}
			constexpr Move(Sign s, Location location) noexcept :
					Move(location.row, location.col, s)
			{
			}
			constexpr explicit Move(Location location) noexcept :
					Move(Sign::NONE, location)
			{
			}
			constexpr explicit Move(uint16_t s) noexcept :
					sign(static_cast<Sign>(s & 3)),
					row((s >> 2) & 127),
					col((s >> 9) & 127)
			{
			}

			constexpr uint16_t toShort() const noexcept
			{
				return static_cast<uint16_t>(sign) | (static_cast<uint16_t>(row) << 2) | (static_cast<uint16_t>(col) << 9);
			}
			constexpr Location location() const noexcept
			{
				return Location(row, col);
			}

			std::string toString() const;
			/**
			 * @brief Converts the move to text representation with format:
			 * 1 character for sign - '_', 'X', 'O' or '|'
			 * 1 character for column - starting from 'a', lowercase, from left to right
			 * 1 or 2 digits for row - starting from 0, from top to bottom
			 *
			 * For example:
			 * Xa0 - cross (or black) in the upper left corner.
			 * Oc2 - circle (or white) in the second row and third column.
			 */
			std::string text() const;

			friend bool operator==(const Move &lhs, const Move &rhs) noexcept
			{
				return (lhs.row == rhs.row) && (lhs.col == rhs.col) && (lhs.sign == rhs.sign);
			}
			friend bool operator!=(const Move &lhs, const Move &rhs) noexcept
			{
				return not (lhs == rhs);
			}
	};

} /* namespace ag */

#endif /* ALPHAGOMOKU_GAME_MOVE_HPP_ */
