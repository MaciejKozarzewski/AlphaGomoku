/*
 * SearchTask.hpp
 *
 *  Created on: Sep 14, 2021
 *      Author: Maciej Kozarzewski
 */

#ifndef ALPHAGOMOKU_MCTS_SEARCHTASK_HPP_
#define ALPHAGOMOKU_MCTS_SEARCHTASK_HPP_

#include <alphagomoku/game/Move.hpp>
#include <alphagomoku/game/Board.hpp>
#include <alphagomoku/mcts/Node.hpp>

#include <cassert>
#include <string>
#include <vector>

namespace ag
{
	/**
	 * \brief Combines Node and Edge selected in each step of select phase.
	 * Node and Edge must always be in pairs.
	 */
	struct NodeEdgePair
	{
			Node *node = nullptr; // non-owning
			Edge *edge = nullptr; // non-owning
	};
	/**
	 *\brief Collects together all information required in a single step of the tree search.
	 */
	class SearchTask
	{
		private:
			std::vector<NodeEdgePair> visited_path;/**< trajectory within the tree visited during select phase */
			std::vector<Edge> prior_edges; /**< edges generated by AB search */
			std::vector<Edge> edges; /**< edges created by EdgeGenerator */

			GameRules game_rules;
			matrix<Sign> board; /**< board representation of a state at the end of visited_path */
			Sign sign_to_move = Sign::NONE;

			matrix<float> policy; /**< policy returned from neural network */
			matrix<Value> action_values; /**< matrix of action values returned from neural network */
			Value value; /**< value returned from neural network */
			ProvenValue proven_value = ProvenValue::UNKNOWN;

			bool is_ready_network = false; /**< flag indicating whether the task has been evaluated by neural network and can be used for edge generation */
			bool is_ready_abs = false; /**< flag indicating whether the task has been evaluated by alpha-beta search and can be used for edge generation */
			bool must_defend = false; /**< flag indicating whether the player to move must defend a threat from the opponent */
		public:
			SearchTask(GameRules rules);
			void set(const matrix<Sign> &base, Sign signToMove);
			int getAbsoluteDepth() const noexcept
			{
				if (visited_path.size() == 0)
					return 0;
				else
					return visited_path.back().node->getDepth();
			}
			int getRelativeDepth() const noexcept
			{
				return visitedPathLength();
			}

			int visitedPathLength() const noexcept
			{
				return static_cast<int>(visited_path.size());
			}
			NodeEdgePair getPair(int index) const noexcept
			{
				assert(index >= 0 && index < visitedPathLength());
				return visited_path[index];
			}
			NodeEdgePair getLastPair() const noexcept
			{
				assert(visitedPathLength() > 0);
				return visited_path.back();
			}
			Edge* getLastEdge() const noexcept
			{
				if (visited_path.size() == 0)
					return nullptr;
				else
					return visited_path.back().edge;
			}

			const std::vector<Edge>& getPriorEdges() const noexcept
			{
				return prior_edges;
			}
			std::vector<Edge>& getPriorEdges() noexcept
			{
				return prior_edges;
			}
			const std::vector<Edge>& getEdges() const noexcept
			{
				return edges;
			}
			std::vector<Edge>& getEdges() noexcept
			{
				return edges;
			}
			GameRules getGameRules() const noexcept
			{
				return game_rules;
			}
			Sign getSignToMove() const noexcept
			{
				return sign_to_move;
			}
			Value getValue() const noexcept
			{
				return value;
			}
			ProvenValue getProvenValue() const noexcept
			{
				return proven_value;
			}
			bool isReadyNetwork() const noexcept
			{
				return is_ready_network;
			}
			bool isReadyABSearch() const noexcept
			{
				return is_ready_abs;
			}
			bool mustDefend() const noexcept
			{
				return must_defend;
			}
			const matrix<Sign>& getBoard() const noexcept
			{
				return board;
			}
			matrix<Sign>& getBoard() noexcept
			{
				return board;
			}
			const matrix<Value>& getActionValues() const noexcept
			{
				return action_values;
			}
			matrix<Value>& getActionValues() noexcept
			{
				return action_values;
			}
			const matrix<float>& getPolicy() const noexcept
			{
				return policy;
			}
			matrix<float>& getPolicy() noexcept
			{
				return policy;
			}

			void append(Node *node, Edge *edge);
			void markAsReadyNetwork() noexcept
			{
				is_ready_network = true;
			}
			void markAsReadyABSearch() noexcept
			{
				is_ready_abs = true;
			}
			void setMustDefendFlag(bool flag) noexcept
			{
				must_defend = flag;
			}

			/**
			 * \param[in] p Pointer to the memory block containing calculated policy.
			 */
			void setPolicy(const float *p) noexcept;

			/**
			 * \param[in] q Pointer to the memory block containing calculated action values.
			 */
			void setActionValues(const float *q) noexcept;
			void setValue(Value v) noexcept
			{
				value = v;
			}
			void setProvenValue(ProvenValue pv) noexcept
			{
				proven_value = pv;
			}

			void addPriorEdge(Move move, Value v, ProvenValue pv);
			void addEdge(Move move, float policyPrior = 0.0f);
			void addEdge(const Edge &other)
			{
				edges.push_back(other);
			}

			std::string toString() const;
	};

} /* namespace ag */

#endif /* ALPHAGOMOKU_MCTS_SEARCHTASK_HPP_ */
