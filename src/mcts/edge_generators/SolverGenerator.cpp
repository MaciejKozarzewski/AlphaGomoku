/*
 * SolverGenerator.cpp
 *
 *  Created on: Jan 24, 2023
 *      Author: Maciej Kozarzewski
 */

#include <alphagomoku/mcts/edge_generators/SolverGenerator.hpp>
#include <alphagomoku/mcts/edge_generators/generator_utils.hpp>
#include <alphagomoku/mcts/SearchTask.hpp>

#include <cassert>
#include <iostream>

namespace ag
{
	SolverGenerator::SolverGenerator(float policyThreshold, int maxEdges) :
			policy_threshold(policyThreshold),
			max_edges(maxEdges)
	{
	}
	std::unique_ptr<EdgeGenerator> SolverGenerator::clone() const
	{
		return std::make_unique<SolverGenerator>(policy_threshold, max_edges);
	}
	void SolverGenerator::generate(SearchTask &task) const
	{
		if (task.mustDefend() or task.isReadySolver())
		{ // we have some prior moves generated by the solver, use them
			assert(task.getPriorEdges().size() > 0); // there must be at least one prior edge
			create_moves_from_solver(task);
		}
		else
		{ // no moves were generated in the solver, use policy to create them
			assert(task.isReadyNetwork());
			create_moves_from_policy(task, policy_threshold);
		}
		// loop over all added moves to update policy and value for those that are proven
		for (auto edge = task.getEdges().begin(); edge < task.getEdges().end(); edge++)
			override_proven_move_policy_and_value(task, *edge);
		if (not task.mustDefend())
			prune_low_policy_moves(task.getEdges(), max_edges);
		renormalize_policy(task.getEdges());

		if (task.getEdges().size() == 0) // TODO remove this later
		{
			std::cout << "---no-moves-generated---\n";
			std::cout << task.toString() << '\n';
			exit(-1);
		}

		assert(task.getEdges().size() > 0);
	}

} /* namespace ag */
