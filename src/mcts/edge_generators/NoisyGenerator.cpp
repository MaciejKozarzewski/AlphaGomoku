/*
 * NoisyGenerator.cpp
 *
 *  Created on: Jan 24, 2023
 *      Author: Maciej Kozarzewski
 */

#include <alphagomoku/mcts/edge_generators/NoisyGenerator.hpp>
#include <alphagomoku/mcts/edge_generators/generator_utils.hpp>
#include <alphagomoku/mcts/SearchTask.hpp>

#include <cassert>

namespace ag
{

	NoisyGenerator::NoisyGenerator(const matrix<float> &noiseMatrix, float noiseWeight, const EdgeGenerator &baseGenerator) :
			noise_matrix(noiseMatrix),
			noise_weight(noiseWeight),
			base_generator(baseGenerator.clone())
	{
	}
	std::unique_ptr<EdgeGenerator> NoisyGenerator::clone() const
	{
		return std::make_unique<NoisyGenerator>(noise_matrix, noise_weight, *base_generator);
	}
	void NoisyGenerator::generate(SearchTask &task) const
	{
		assert(task.isReadyNetwork() or task.isReadySolver());

		if (task.getRelativeDepth() == 0)
		{
			if (task.mustDefend() or task.isReadySolver())
			{ // we have some prior moves generated by the solver, use them
				assert(task.getPriorEdges().size() > 0); // there must be at least on prior edge
				create_moves_from_solver(task);
			}
			else
			{ // no moves were generated in the solver, use policy to create them
				assert(task.isReadyNetwork());
				create_moves_from_policy(task, 0.0f);
			}

			for (auto edge = task.getEdges().begin(); edge < task.getEdges().end(); edge++)
			{
				check_terminal_conditions(task, *edge);
				override_proven_move_policy_and_value(task, *edge);
				const Move m = edge->getMove();
				edge->setPolicyPrior((1.0f - noise_weight) * edge->getPolicyPrior() + noise_weight * noise_matrix.at(m.row, m.col));
			}
			renormalize_policy(task.getEdges());
			assert(task.getEdges().size() > 0);
		}
		else
			base_generator->generate(task);
	}

} /* namespace ag */

